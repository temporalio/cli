// BUGGY VERSION - Use this for demo
// Replace activities.go with this file to introduce a bug
//
// BUG: Payment gateway fails for "premium" seats (A6-A10)
// This simulates a misconfigured payment tier that causes consistent failures.

package ticketdrop

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"strconv"
	"strings"
	"sync"
	"time"

	"go.temporal.io/sdk/activity"
)

// SeatInventory tracks available seats per event.
type SeatInventory struct {
	mu         sync.Mutex
	seats      map[string][]string // eventID -> available seats
	userSeats  map[string]string   // "eventID:userID" -> seat (for idempotency)
	seatOwners map[string]string   // "eventID:seat" -> userID
}

// NewSeatInventory creates an inventory with 10 seats per event.
func NewSeatInventory() *SeatInventory {
	return &SeatInventory{
		seats:      make(map[string][]string),
		userSeats:  make(map[string]string),
		seatOwners: make(map[string]string),
	}
}

func (inv *SeatInventory) initEvent(eventID string) {
	if _, exists := inv.seats[eventID]; !exists {
		// Initialize 10 seats: A1-A10
		seats := make([]string, 10)
		for i := 0; i < 10; i++ {
			seats[i] = fmt.Sprintf("A%d", i+1)
		}
		inv.seats[eventID] = seats
	}
}

// Reserve attempts to reserve a seat for an event.
func (inv *SeatInventory) Reserve(eventID, userID string) (string, bool, error) {
	inv.mu.Lock()
	defer inv.mu.Unlock()

	inv.initEvent(eventID)

	userKey := fmt.Sprintf("%s:%s", eventID, userID)
	if existingSeat, exists := inv.userSeats[userKey]; exists {
		return existingSeat, true, nil
	}

	available := inv.seats[eventID]
	if len(available) == 0 {
		return "", false, errors.New("sold out: no seats available")
	}

	seat := available[0]
	inv.seats[eventID] = available[1:]
	inv.userSeats[userKey] = seat
	seatKey := fmt.Sprintf("%s:%s", eventID, seat)
	inv.seatOwners[seatKey] = userID

	return seat, false, nil
}

func (inv *SeatInventory) Available(eventID string) int {
	inv.mu.Lock()
	defer inv.mu.Unlock()
	inv.initEvent(eventID)
	return len(inv.seats[eventID])
}

func (inv *SeatInventory) Release(eventID, userID, seat string) bool {
	inv.mu.Lock()
	defer inv.mu.Unlock()

	userKey := fmt.Sprintf("%s:%s", eventID, userID)
	seatKey := fmt.Sprintf("%s:%s", eventID, seat)

	if inv.seatOwners[seatKey] != userID {
		return false
	}

	delete(inv.userSeats, userKey)
	delete(inv.seatOwners, seatKey)
	inv.seats[eventID] = append(inv.seats[eventID], seat)

	return true
}

type Activities struct {
	Inventory *SeatInventory
}

func (a *Activities) ReserveSeat(ctx context.Context, input ReserveSeatInput) (ReserveSeatResult, error) {
	logger := activity.GetLogger(ctx)
	logger.Info("Reserving seat", "user_id", input.UserID, "event_id", input.EventID)

	seatNumber, wasRetry, err := a.Inventory.Reserve(input.EventID, input.UserID)
	if err != nil {
		logger.Warn("Reservation failed", "error", err)
		return ReserveSeatResult{}, err
	}

	time.Sleep(1 * time.Second)

	if wasRetry {
		logger.Info("Returning existing reservation (idempotent)", "seat", seatNumber)
	} else {
		logger.Info("Seat reserved", "seat", seatNumber, "remaining", a.Inventory.Available(input.EventID))
	}

	reservationID := fmt.Sprintf("res-%s-%s-%d", input.UserID, input.EventID, time.Now().UnixMilli())

	return ReserveSeatResult{
		ReservationID: reservationID,
		SeatNumber:    seatNumber,
		ExpiresAt:     time.Now().Add(5 * time.Minute),
	}, nil
}

func (a *Activities) ReleaseSeat(ctx context.Context, eventID, userID, seat string) error {
	logger := activity.GetLogger(ctx)
	logger.Info("Releasing seat (compensation)", "user_id", userID, "event_id", eventID, "seat", seat)

	released := a.Inventory.Release(eventID, userID, seat)
	if !released {
		logger.Warn("Seat was not released (may not be owned by user)", "seat", seat)
		return nil
	}

	logger.Info("Seat released", "seat", seat, "available", a.Inventory.Available(eventID))
	return nil
}

// ProcessPayment charges the credit card.
// ðŸ› BUG: Premium seats (A6-A10) always fail due to misconfigured payment tier
func (a *Activities) ProcessPayment(ctx context.Context, input ProcessPaymentInput) (ProcessPaymentResult, error) {
	logger := activity.GetLogger(ctx)
	logger.Info("Processing payment", "user_id", input.UserID, "amount", input.Amount)

	time.Sleep(2 * time.Second)

	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// ðŸ› BUG: This extracts seat number from reservation ID incorrectly
	//    The payment gateway rejects "premium tier" seats (A6-A10)
	//    because the tier configuration is wrong.
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// 
	// The reservation ID format is: res-{userID}-{eventID}-{timestamp}
	// But we're trying to parse seat info that isn't there!
	// This causes seats A6+ to fail because of a hardcoded check.
	
	// Simulate checking seat tier (BUG: always fails for seats 6-10)
	// In a real system this might be: getPremiumTier(reservationID)
	if isPremiumSeat(input.ReservationID) {
		logger.Error("Payment gateway rejected premium tier", "reservation", input.ReservationID)
		return ProcessPaymentResult{}, errors.New("payment gateway error: premium tier not configured for merchant account")
	}
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	// Normal 10% random failure
	if rand.Float64() < 0.1 {
		logger.Warn("Payment failed", "user_id", input.UserID)
		return ProcessPaymentResult{}, errors.New("payment declined: insufficient funds")
	}

	transactionID := fmt.Sprintf("pay-%s-%d", input.UserID, time.Now().UnixMilli())
	logger.Info("Payment successful", "transaction_id", transactionID)

	return ProcessPaymentResult{
		TransactionID: transactionID,
		ChargedAmount: input.Amount,
	}, nil
}

// ðŸ› BUG: This function has flawed logic
// It's supposed to check if a seat is "premium" but the reservation ID
// doesn't actually contain seat information in a parseable way.
// This causes false positives for users with IDs containing digits 6-10.
func isPremiumSeat(reservationID string) bool {
	// Buggy logic: tries to extract seat number from reservation ID
	// but reservation ID format is: res-{userID}-{eventID}-{timestamp}
	// This incorrectly matches user IDs like "fan-6", "fan-7", etc.
	parts := strings.Split(reservationID, "-")
	for _, part := range parts {
		if num, err := strconv.Atoi(part); err == nil {
			if num >= 6 && num <= 10 {
				return true // BUG: False positive!
			}
		}
	}
	return false
}

func (a *Activities) IssueTicket(ctx context.Context, input IssueTicketInput) (IssueTicketResult, error) {
	logger := activity.GetLogger(ctx)
	logger.Info("Issuing ticket", "user_id", input.UserID, "seat", input.SeatNumber)

	ticketID := fmt.Sprintf("tkt-%s-%s-%d", input.EventID, input.SeatNumber, time.Now().UnixMilli())
	qrCode := fmt.Sprintf("QR:%s:%s:%s", ticketID, input.UserID, input.TransactionID)

	return IssueTicketResult{
		TicketID: ticketID,
		QRCode:   qrCode,
	}, nil
}

func (a *Activities) SendEmail(ctx context.Context, userID, confirmationID, qrCode string) error {
	logger := activity.GetLogger(ctx)
	logger.Info("Sending confirmation email", "user_id", userID, "confirmation_id", confirmationID)
	return nil
}

func (a *Activities) SendSMS(ctx context.Context, userID, confirmationID string) error {
	logger := activity.GetLogger(ctx)
	logger.Info("Sending confirmation SMS", "user_id", userID, "confirmation_id", confirmationID)
	return nil
}
