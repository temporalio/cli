name: Continuous Integration
on:
  pull_request:
  push:
    branches:
      - main

permissions:
  contents: read
  actions: write

jobs:
  validate-server-version:
    name: Validate Server Version
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate server dependency version
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const SERVER_MODULE = 'go.temporal.io/server';

            // Parse major.minor from a version string like "v1.30.0-148.4" or "v1.29.2"
            function parseMajorMinor(version) {
              const match = version.match(/^v?(\d+)\.(\d+)/);
              if (!match) return null;
              return { major: parseInt(match[1], 10), minor: parseInt(match[2], 10) };
            }

            // 1. Read and parse go.mod
            const goModContent = fs.readFileSync('go.mod', 'utf-8');
            const serverVersionMatch = goModContent.match(new RegExp(`${SERVER_MODULE.replace(/\//g, '\\/')}\\s+(v[^\\s]+)`));

            if (!serverVersionMatch) {
              core.setFailed(`Could not find ${SERVER_MODULE} dependency in go.mod`);
              return;
            }

            const serverVersion = serverVersionMatch[1];
            core.info(`Found server dependency: ${SERVER_MODULE}@${serverVersion}`);

            // 2. Validate it's a tagged version (not a pseudo-version)
            const pseudoPattern = /-\d{14}-[a-f0-9]{12}$/;
            if (pseudoPattern.test(serverVersion)) {
              core.setFailed(`Server dependency must be a tagged version, not a pseudo-version: ${serverVersion}`);
              return;
            }
            core.info('✓ Version is a valid tagged version');

            // 3. Fetch latest release from GitHub
            const { data: release } = await github.rest.repos.getLatestRelease({
              owner: 'temporalio',
              repo: 'temporal',
            });
            const latestRelease = release.tag_name;
            core.info(`Latest GitHub release: ${latestRelease}`);

            // 4. Validate version doesn't exceed next release (major.minor+1)
            const serverVer = parseMajorMinor(serverVersion);
            const latestVer = parseMajorMinor(latestRelease);

            if (!serverVer || !latestVer) {
              core.setFailed(`Could not parse versions: server=${serverVersion}, latest=${latestRelease}`);
              return;
            }

            const maxAllowedMinor = latestVer.minor + 1;
            core.info(`  Server version: ${serverVer.major}.${serverVer.minor}.x`);
            core.info(`  Latest release: ${latestVer.major}.${latestVer.minor}.x`);
            core.info(`  Max allowed: ${latestVer.major}.${maxAllowedMinor}.x`);

            const exceedsVersion =
              serverVer.major > latestVer.major ||
              (serverVer.major === latestVer.major && serverVer.minor > maxAllowedMinor);

            if (exceedsVersion) {
              core.setFailed(
                `Server dependency version ${serverVersion} exceeds allowed range.\n` +
                `Max allowed: ${latestVer.major}.${maxAllowedMinor}.x (latest release + 1 minor)\n` +
                `Latest release: ${latestRelease}`
              );
              return;
            }

            core.info('✓ Server dependency version validation passed!')

  build-test:
    strategy:
      fail-fast: false
      matrix:
        os:
          [
            ubuntu-latest,
            macos-latest,
            macos-15-intel,
            windows-latest,
            ubuntu-arm,
          ]
        include:
          - os: ubuntu-latest
            checkGenCommands: true
            cloudTestTarget: true
          - os: ubuntu-arm
            runsOn: buildjet-4vcpu-ubuntu-2204-arm
    runs-on: ${{ matrix.runsOn || matrix.os }}
    env:
      # We can't check this directly in the cloud test's `if:` condition below,
      # so we have to check it here and report it in an env variable.
      HAS_SECRETS: ${{ secrets.TEMPORAL_CLIENT_CERT != '' && secrets.TEMPORAL_CLIENT_KEY != '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Install gotestsum
        run: go install gotest.tools/gotestsum@latest

      - name: Create junit-xml directory
        run: mkdir junit-xml

      - name: Test
        run: gotestsum --junitfile junit-xml/${{matrix.os}}.xml -- ./...

      - name: Upload junit-xml artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: junit-xml--${{github.run_id}}--${{github.run_attempt}}--${{matrix.os}}
          path: junit-xml
          retention-days: 14

      - name: Regen code, confirm unchanged
        if: ${{ matrix.checkGenCommands }}
        run: |
          go run ./cmd/gen-commands -input internal/temporalcli/commands.yaml -pkg temporalcli -context "*CommandContext" > internal/temporalcli/commands.gen.go
          go run ./cmd/gen-commands -input cliext/option-sets.yaml -pkg cliext > cliext/flags.gen.go
          git diff --exit-code

      - name: Generate docs, confirm working
        if: ${{ matrix.checkGenCommands }}
        run: |
          go run ./cmd/gen-docs -input internal/temporalcli/commands.yaml -input cliext/option-sets.yaml -output dist/docs

      - name: Test cloud mTLS
        if: ${{ matrix.cloudTestTarget && env.HAS_SECRETS == 'true' }}
        env:
          TEMPORAL_ADDRESS: ${{ vars.TEMPORAL_CLIENT_NAMESPACE }}.tmprl.cloud:7233
          TEMPORAL_NAMESPACE: ${{ vars.TEMPORAL_CLIENT_NAMESPACE }}
          TEMPORAL_TLS_CERT: client.crt
          TEMPORAL_TLS_CERT_CONTENT: ${{ secrets.TEMPORAL_CLIENT_CERT }}
          TEMPORAL_TLS_KEY: client.key
          TEMPORAL_TLS_KEY_CONTENT: ${{ secrets.TEMPORAL_CLIENT_KEY }}
        shell: bash
        run: |
          printf '%s\n' "$TEMPORAL_TLS_CERT_CONTENT" >> client.crt
          printf '%s\n' "$TEMPORAL_TLS_KEY_CONTENT" >> client.key
          go run ./cmd/temporal workflow list --limit 2

      - name: Test cloud API key env var
        if: ${{ matrix.cloudTestTarget && env.HAS_SECRETS == 'true' }}
        env:
          TEMPORAL_ADDRESS: us-west-2.aws.api.temporal.io:7233
          TEMPORAL_NAMESPACE: ${{ vars.TEMPORAL_CLIENT_NAMESPACE }}
          TEMPORAL_API_KEY: ${{ secrets.TEMPORAL_CLIENT_CLOUD_API_KEY }}
        shell: bash
        run: go run ./cmd/temporal workflow list --limit 2

      - name: Test cloud API key arg
        if: ${{ matrix.cloudTestTarget && env.HAS_SECRETS == 'true' }}
        env:
          TEMPORAL_ADDRESS: us-west-2.aws.api.temporal.io:7233
          TEMPORAL_NAMESPACE: ${{ vars.TEMPORAL_CLIENT_NAMESPACE }}
        shell: bash
        run: go run ./cmd/temporal workflow list --limit 2 --api-key ${{ secrets.TEMPORAL_CLIENT_CLOUD_API_KEY }}
